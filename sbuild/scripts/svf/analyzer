#!/bin/bash
# Parameters
DSC=$1
SRC=$2

DSC=$(ls *.dsc)

# Working directories
PWD_PKG=$(pwd)
cd $SRC
PWD_SRC=$(pwd)
cd ../

# Global variables
R_OPTION_PARAM="cgraph.txt?all=1&n=p&type=1"
NAME=$(cat $DSC | grep '^Source: ')
NAME=${NAME#"Source: "}
NAME="$(echo -e "${NAME}" | tr -d '[:space:]')"
VERSION=$(cat $DSC | grep '^Version: ')
VERSION=${VERSION#"Version: "}
VERSION="$(echo -e "${VERSION}" | tr -d '[:space:]')"
ARCH="$(dpkg --print-architecture)"
PKG="$NAME"

# Directories
DEST="/callgraphs/"
# $DEST_PKG/binary_package/{build.err,svf.err,fcan.err,status,fcg.json}
DEST_PKG="$DEST$PKG/$VERSION/$ARCH"
BINARIES_PER_PKG="$PWD_SRC/binaries_per_pkg"
SVF_DIR="$PWD_SRC/svf_data"
PACKAGES="$PWD_PKG/packages"

BINARIES=''
SYMLINKED=''
USED_BINARIES=''
TOTAL_BIN=''
HAS_DEBS=0

cd $SRC
mkdir -p $BINARIES_PER_PKG
mkdir -p $SVF_DIR
mkdir -p $PACKAGES
mkdir -p $DEST_PKG

prepare_env() {
    export LLVM_SRC=/usr/local/installations/llvm-7.0.0.src
    export LLVM_OBJ=/usr/lib/llvm-7/build
    export LLVM_DIR=/usr/lib/llvm-7/build
    export SVF_HOME=/usr/local/installations/SVF/
    export PATH=$SVF_HOME/Release-build/bin:$PATH
    export LLVM_COMPILER=clang
    export CFLAGS='-g'
    # replace '=' and ':=' with '?=' in rules Makefile, in templates Makefiles
    sed -i -E "s/CC [:]?=/CC ?=/g" debian/rules
    sed -i -E "s/CC[:]?=/CC?=/g" debian/rules
    for i in Makefile*; do
        sed -i -E "s/CC [:]?=/CC ?=/g" $i 2> /dev/null
        sed -i -E "s/CC[:]?=/CC?=/g" $i 2> /dev/null
    done
    ln -s /usr/bin/clang-7 /usr/bin/clang
    ln -s /usr/bin/opt-7 /usr/bin/opt
    ln -s /usr/bin/clang++-7 /usr/bin/clang++
    ln -s /usr/bin/llvm-link-7 /usr/bin/llvm-link
    ln -s /usr/local/bin/wllvm /usr/bin/wllvm
    ln -s /usr/local/bin/wllvm++ /usr/bin/wllvm++
}

build() {
    printf "\n###Debug: build\n"
    echo "tool: svf" >> $DEST_PKG/report
    CC=/usr/bin/wllvm CXX=/usr/bin/wllvm++ dpkg-buildpackage -b 2>error
    STATUS=$?
    if [ $STATUS -ne 0 ]; then
        echo "#build_heuristic: true" >> $DEST_PKG/report
        cp error $DEST_PKG/old_build.err
        HAS_DEBS=$STATUS
        ./debian/rules clean && \
            CC=/usr/bin/wllvm CXX=/usr/bin/wllvm++ ./configure --prefix=$(pwd)/debian/tmp 2> config
        CC=/usr/bin/wllvm CXX=/usr/bin/wllvm++ make DESTDIR=$(pwd)/debian/tmp 2> error
        STATUS=$?
        if [ $STATUS -ne 0 ]; then
            cp config $DEST_PKG/config.err
            cp error $DEST_PKG/build.err
            echo "build: failed" >> $DEST_PKG/report
            exit -1
        fi
    fi
    cp error $DEST_PKG/build.war
    echo "build: success" >> $DEST_PKG/report
}

detect_binaries() {
    printf "\n###Debug: detect_binaries\n"
    EXECUTABLES=$(find -type f -executable -exec sh -c \
        "file -i '{}' | grep -q 'executable; charset=binary'" \; -print)
    ARCHIVES=$(find -type f -exec sh -c \
        "file -i '{}' | grep -q 'archive; charset=binary'" \; -print)
    SHAREDLIBS=$(find -type f -exec sh -c \
        "file -i '{}' | grep -q 'sharedlib; charset=binary'" \; -print)
    BINARIES="${EXECUTABLES} ${ARCHIVES} ${SHAREDLIBS}"
    SYMLINKED=$(find -type l -exec sh -c \
        "file -i '{}' | grep -q 'charset=binary'" \; -print)
    TOTAL_BIN="${BINARIES} ${SYMLINKED}"
    count=$(wc -w <<< "$TOTAL_BIN")
    if [ "$count" -eq "0" ]; then
        echo "detect_binaries: failed" >> $DEST_PKG/report
        exit -1
    fi
    echo "detect_binaries: success" >> $DEST_PKG/report
    echo "#binaries: $count" >> $DEST_PKG/report
}

detect_packages() {
    # Keep only those inside the debian directory
    printf "\n###Debug: detect_packages\n"
    # Number of packages
    NUM=$(awk '/^Package:/{a++}END{print a}' debian/control)
    # Names of packages
    NAMES=$(grep "Package:" debian/control | cut -d ":" -f2 | awk '{$1=$1};1')
    if [ "$NUM" -gt "1" ]; then
        for n in $NAMES; do
            prefix="./debian/tmp/"
            install_file="debian/$n.install"
            touch $BINARIES_PER_PKG/$n
            if [ -f $install_file ]; then
                for path in $(cat $install_file | cut -d ' ' -f1); do
                    for f in $(find $prefix$path -type f); do
                        x=$(basename -- "$f")
                        if [[ "$TOTAL_BIN" == *"$x"* ]]; then
                            # We may need to look for hole path
                            # It may have duplicates
                            echo "$x" >> $BINARIES_PER_PKG/$n
                            USED_BINARIES="${USED_BINARIES} ${x}"
                        fi
                    done
                done
            fi
        done
    else
        for bin in $TOTAL_BIN; do
            x=$(basename -- "$bin")
            # It may have duplicates
            echo "$x" >> $BINARIES_PER_PKG/$NAMES
            USED_BINARIES="${USED_BINARIES} ${x}"
        done
    fi
    # Add symlinked
    for i in $SYMLINKED; do
        b=$(basename -- "$i")
        if [[ $USED_BINARIES == *"$b"* ]]; then
            original=$(readlink -f $i)
            original=$(basename -- "$original")
            USED_BINARIES="${USED_BINARIES} ${original}"
        fi
    done
    # Remove duplicates
    USED_BINARIES=$(echo "$USED_BINARIES" | awk '{for (i=1;i<=NF;i++) if (!USED_BINARIES[$i]++) printf("%s%s",$i,FS)}{printf("\n")}')
    echo "#detect_packages_number: $NUM" >> $DEST_PKG/report
    temp_names=$(tr '\n' ' ' <<< $NAMES)
    echo "detect_packages: $temp_names" >> $DEST_PKG/report
}

run_svf() {
    printf "\n###Debug: run_svf\n"
    for i in $BINARIES; do
        echo "Processing $i"
        # When we know the debs from the first build we can skip
        # binaries that aren't used in debs
        if [ $HAS_DEBS -eq 0 ]; then
            x=$(basename -- "$i")
            if [[ ! $USED_BINARIES == *"$x"* ]]; then
                echo "Skip $i"
                echo "#analysis: $i: not in USED_BINARIES" >> $DEST_PKG/report
                continue
            fi
        fi
        extract-bc -b $i 2> bc_error
        if [ $? -ne 0 ]; then
            echo "analysis: $i: failed: extract_bc" >> $DEST_PKG/report
            cp bc_error $DEST_PKG/$i.bc.err
            continue
        fi
        echo "#extract_bc $i: success" >> $DEST_PKG/report
        /usr/local/bin/extract-function-info.sh $i.bc /usr/local/bin/libLLVMFuncInfoPass.so > $i.txt 2> error
        if [ $? -ne 0 ]; then
            echo "analysis: $i: failed: svf" >> $DEST_PKG/report
            cp error $DEST_PKG/$i.svf.err
            continue
        fi
        echo "#svf $i: success" >> $DEST_PKG/report
        echo "analysis: $i: success" >> $DEST_PKG/report
        bname=$(basename $i)
        cp $i.txt $SVF_DIR/$bname.txt
        cp $i.bc $SVF_DIR/$bname.bc
        cp $i.wpa $SVF_DIR/$bname.wpa
    done
    for i in $SYMLINKED; do
        original=$(readlink -f $i)
        original=$(basename -- "$original")
        bname=$(basename $i)
        if [ -f "$SVF_DIR/$original.txt" ]; then
            cp $SVF_DIR/$original.txt $SVF_DIR/$bname.txt
        fi
    done
}

# If build failed we want to rebuild the project to get the .deb files
rebuild() {
    sed -i -E 's/CC \?=/CC =/g' debian/rules
    sed -i -E 's/CC\?=/CC=/g' debian/rules
    for i in Makefile*; do
        sed -i -E 's/CC \?=/CC =/g' $i 2> /dev/null
        sed -i -E 's/CC\?=/CC=/g' $i 2> /dev/null
    done
    dpkg-buildpackage -b 2> error
    if [ $? -ne 0 ]; then
        cp error $DEST_PKG/rebuild.err
        echo "produce_debs: failed" >> $DEST_PKG/report
        exit -1
    fi
    echo "produce_debs: success" >> $DEST_PKG/report
}

produce_callgraphs() {
    pip3 install setuptools
    pip3 install pygraphviz
    pip3 install networkx
    echo "
    {
        \"CScout\": {
            \"forge\": \"\",
            \"constraints\": \"\",
            \"architecture\": \"\",
            \"regex\": [
                \"^/usr/local/include/cscout.*\"
            ],
            \"keep\": false
        }
    }
    " > custom_deps.json
    for pkg in $(ls $BINARIES_PER_PKG); do
            mkdir -p $PACKAGES/$pkg
            if ! cp $PWD_PKG/${pkg}_*.*deb $PACKAGES/$pkg ; then
                echo "produce_callgraph: $pkg: failed: missing deb" >> $DEST_PKG/report
                rm -rf $PACKAGES/$pkg
                continue
            fi
            touch $PACKAGES/$pkg/cgraph.txt
            for bin in $(cat binaries_per_pkg/$pkg); do
                cat $SVF_DIR/$bin.txt >> $PACKAGES/$pkg/cgraph.txt
            done
            if [ ! -s "$PACKAGES/$pkg/cgraph.txt" ]; then
                echo "produce_callgraph: $pkg: failed: empty" >> $DEST_PKG/report
                rm -rf $PACKAGES/$pkg
                continue
            fi
            cp $PWD_PKG/*.dsc $PACKAGES/$pkg/$pkg.dsc
            cp $PWD_SRC/debian/changelog $PACKAGES/$pkg/$pkg.changelog
    done
    for d in $(ls $PACKAGES); do
        mkdir -p $DEST_PKG/$d/
        if fcan -c custom_deps.json -s $PKG -a svf::andersen $PACKAGES/$d 2> fcan_error; then
            cp $PACKAGES/$d/can_cgraph.json $DEST_PKG/$d/fcg.json
            echo "produce_callgraph: $d: success" >> $DEST_PKG/report
        else
            # It will catch all the errors, such as when a packages
            # does not have a .deb file
            cp fcan_error $DEST_PKG/$d/fcan.err
            echo "produce_callgraph: $d: failed": fcan >> $DEST_PKG/report
        fi
    done
    cp $PWD_SRC/debian/changelog $DEST_PKG/changelog
}

main () {
    prepare_env && build && detect_binaries
    # Optimization
    # Use info from detect_packages before run_svf 
    # if the packages were generated in the first build
    if [ $HAS_DEBS -ne 0 ]; then
        run_svf && rebuild && detect_packages 
    else
        echo "produce_debs: success" >> $DEST_PKG/report
        detect_packages && run_svf
    fi
    produce_callgraphs
}

main

exit 0
