#!/bin/bash

R_OPTION_PARAM="cgraph.txt?all=1"

# run CSsout on package
rm -rf /callgraph/*
mkdir -p /callgraph
mkdir -p /var/run/csmake-spy
cd $2


# Copy changelog
cp debian/changelog /callgraph/
# Copy dsc file
cp $1 /callgraph/


copy_files() {
    if [ -z "$1" ]; then
        graph="cgraph.txt"
    else
        graph="$1.txt"
    fi
    cp cgraph.txt /callgraph/$graph
    if ls ../*.deb 1> /dev/null 2>&1; then
        cp ../*.deb /callgraph/
    fi
    if ls ../*.udeb 1> /dev/null 2>&1; then
        cp ../*.udeb /callgraph/
    fi
}

# FIXME
run_fcan() {
    # Install fcan dependencies
    pip3 install setuptools
    pip3 install pydpkg
    # Create file to filter out CScout nodes from canonical call graph
    echo "
    {
        \"CScout\": {
            \"forge\": \"\",
            \"constraints\": \"\",
            \"architecture\": \"\",
            \"regex\": [
                \"^/usr/local/include/cscout.*\"
            ],
            \"keep\": false
        }
    }
    " > custom_deps.json
    # Run fcan
    if fcan -c custom_deps.json /callgraph/ 2> /callgraph/fcan_error; then
        echo "done" > /callgraph/report
    else
        echo "failed-fcan" > /callgraph/report
        exit 1
    fi
}

run_cscout() {
    if [ -z "$1" ]; then
        cs="make.cs"
    else
        cs=$1
    fi
    # Run CScout
    if cscout -R $R_OPTION_PARAM $cs 2>cscout_error$1; then
        # Save warnings
        if [[ -f "cscout_error$1" ]]; then
            cp cscout_error$1 /callgraph/cscout_warnings$1
        fi
        if [[ -f "cgraph.txt" && ! -s "cgraph.txt" ]]; then
            echo "failed-empty$1" > /callgraph/report
            exit 1
        else
            # Copy files
            copy_files $1
            # Run fcan
            run_fcan
        fi
    else
        cp cscout_error /callgraph/
        echo "failed-cscout" > /callgraph/report
        exit 1
    fi
}

run_csmake() {
    # Run csmake
    MAKE=/usr/local/bin/csmake dpkg-buildpackage -b 2> csmake_error
    # Check if make.cs was produced
    if [[ -f "make.cs" ]]; then
        # Save Warnings
        if [[ -f "csmake_error" ]]; then
            cp csmake_error /callgraph/csmake_warnings
        fi
        # Number of packages
        num=$(awk '/^Package:/{a++}END{print a}' debian/control)
        if [ "$num" -gt "1" ]; then
            # Separate CScout Projects to different CScout files (.cs)
            separate.py make.cs
            # Find packages names
            names=$(grep "Package:" debian/control | cut -d ":" -f2 | awk '{$1=$1};1')
            # Find which targets included each Packages
            mkdir -p debian_targets_per_pkg
            for i in $names; do
                for path in $(cat debian/"$i".install); do
                    temp=debian/tmp/$path
                    for f in $temp; do
                        # Find targets
                        if file -i $f | grep "charset=binary" | grep -q "x-sharedlib;\|x-sharedlib;"; then
                            echo "$f" >> debian_files_per_pkg/$i
                        fi
                    done
                done
            done
            # Find which cs file match each target (spy-install)
            # A file that containes lines such as the following
            # target installation cs_file
            # foo debian/tmp/usr/bin/foo foo.cs
            # Compose cs files for each Package
            for pkg in $(ls debian_targets_per_pkg); do
                for target in $(cat "$pkg"); do
                    match.py spy_file target >> "$pkg".cs
                done
                # Run CScout
                run_cscout $pkg
            done
        else
            # Run CScout
            run_cscout
        fi
    else
        # Copy errors
        cp csmake_error /callgraph/
        # Log Status
        echo "failed-csmake" > /callgraph/report
        exit 1
    fi
}

run_csmake

rm -rf /var/run/csmake-spy
